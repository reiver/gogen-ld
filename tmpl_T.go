package main

import (
	"github.com/reiver/gogen-ld/driver"
)

func init() {

	driver := gendriver.SimpleDriver{
		NamePattern: "{{.Name}}.go",
		TextTemplate:
`// DO NOT EDIT
//
// MACHINE GENERATED BY THE FOLLOWING COMMAND
// gogen-ld --pkg={{.Pkg}} --type={{.Type}} --name={{.Name}}
package {{.Pkg}}

// THIS FILE IS GENERATED; DO NOT EDIT

import (
{{range .Imports}}
	"{{.}}"
{{end}}
	"fmt"
)

// THIS FILE IS GENERATED; DO NOT EDIT

// {{.Name}} is this package's version of Go's built-in {{.Type}} type.
//
// A difference being that this package's {{.Name}} has the ability to express (a certain kind of)
// a lack of a value.
//
// More specifically, that the value has not been loaded.
//
// (For example, that the value for this field was not loaded from the database.)
//
// To assign a value to something of type {{.Name}} you would do something like the following:
//
//	var x {{.Pkg}}.{{.Name}} = {{.Pkg}}.{{.Name}}Some(value)
//
// To assign the "not loaded" version of a "lack of a value" to a something of type {{.Name}}
// you would do something like the following:
//
//	var i64 {{.Pkg}}.{{.Name}} = {{.Name}}NotLoaded()
//
// To see if one thing of type {{.Name}} is equal to something else of type {{.Name}}, you can do something
// like the following:
//
//	var a {{.Pkg}}.{{.Name}}
//	// ...
//	
//	var b {{.Pkg}}.{{.Name}}
//	// ...
//	
//	if a == b {
//		// ...
//	}
//
// (I.e., you can use the normal Go "==" operator for checking for equality.)
//
// To see if one thing of type {{.Name}} is not equal to something else of type {{.Name}}, you can do something
// like the following:
//
//	var a {{.Pkg}}.{{.Name}}
//	// ...
//	
//	var b {{.Pkg}}.{{.Name}}
//	// ...
//	
//	if a != b {
//		// ...
//	}
//
// (I.e., you can you the normal Go "!=" operator for checking for inequality.)
//
// So that means you can do things such as:
//
//	if i64 == {{.Pkg}}.{{.Name}}Some(5) {
//		// ...
//	}
//
// And:
//
//	if i64 == {{.Pkg}}.{{.Name}}NotLoaded() {
//		// ...
//	}
//
// To unwrap an {{.Name}}, and (potentially) get at the number (the {{.Type}}) inside of it,
// if indeed the {{.Name}} has a value, you could do something like the following:
//
//	var i64 {{.Pkg}}.{{.Name}}
//
//	switch n := i64.Match().(type) {
//	case {{.Pkg}}.{{.Name}}Value:
//		// ...
//
//	case {{.Pkg}}.{{.Name}}NoneNotLoaded:
//		// ...
//
//	default:
//		// ...
//	}
type {{.Name}} struct {
	value {{.Type}}
	loaded bool
}

// THIS FILE IS GENERATED; DO NOT EDIT

func (receiver {{.Name}}) Match() {{.Name}}Matcher {
	if !receiver.loaded {
		return {{.Name}}NoneNotLoaded{}
	}

	return {{.Name}}Value(receiver.value)
}

// THIS FILE IS GENERATED; DO NOT EDIT

func (receiver {{.Name}}) String() string {
	if !receiver.loaded {
		return "{{.Name}}NotLoaded()"
	}

	return fmt.Sprintf("{{.Name}}Some(%d)", receiver.value)
}

// THIS FILE IS GENERATED; DO NOT EDIT

func (receiver {{.Name}}) {{.Name}}() (value {{.Type}}, err error) {
	if !receiver.loaded {
		err = errNotLoaded
		return
	}

	return receiver.value, nil
}
`}

	registry := gendriver.Registry
	if nil == registry {
		panic(errNilRegistry)
	}

	if err := registry.Register(driver.NamePattern, driver); nil != err {
		panic(err)
	}
}
